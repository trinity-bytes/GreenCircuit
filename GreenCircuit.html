<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üå± GreenCircuit - Optimizaci√≥n de Rutas de Recolecci√≥n</title>

    <!-- Cytoscape.js desde CDN (se descarga autom√°ticamente) -->
    <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        line-height: 1.6;
        background-color: #f5f5f5;
      }

      h1,
      h2,
      h3 {
        margin: 15px 0;
      }

      section {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ddd;
        background-color: white;
        border-radius: 5px;
      }

      button {
        padding: 10px 20px;
        margin: 5px;
        cursor: pointer;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f0f0f0;
      }

      button:hover {
        background-color: #e0e0e0;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      input,
      select {
        padding: 8px;
        margin: 5px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      #graph-container {
        width: 100%;
        height: 500px;
        border: 2px solid #333;
        margin: 10px 0;
        background-color: white;
      }

      #log-container {
        width: 100%;
        height: 400px;
        border: 2px solid #333;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 12px;
        padding: 10px;
        background-color: #f9f9f9;
      }

      .log-entry {
        margin: 2px 0;
        padding: 2px 0;
      }

      .log-timestamp {
        color: #666;
        font-size: 10px;
      }

      .log-header {
        font-weight: bold;
        font-size: 14px;
        color: #2196f3;
      }

      .log-phase {
        font-weight: bold;
        color: #ff9800;
      }

      .log-info {
        color: #333;
      }

      .log-success {
        color: #4caf50;
        font-weight: bold;
      }

      .log-warning {
        color: #ff9800;
      }

      .log-error {
        color: #f44336;
        font-weight: bold;
      }

      .log-cycle {
        color: #9c27b0;
        font-family: monospace;
      }

      .log-result {
        color: #00796b;
      }

      .log-savings {
        color: #4caf50;
        font-weight: bold;
      }

      .log-separator {
        color: #999;
        margin: 10px 0;
      }

      .hidden {
        display: none;
      }

      .info-box {
        background-color: #e3f2fd;
        padding: 10px;
        margin: 10px 0;
        border-left: 4px solid #2196f3;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background-color: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background-color: #4caf50;
        transition: width 0.3s ease;
      }

      table.adjacency-matrix {
        border-collapse: collapse;
        margin: 10px 0;
        font-family: monospace;
      }

      table.adjacency-matrix th,
      table.adjacency-matrix td {
        padding: 5px;
        border: 1px solid #ccc;
        text-align: center;
      }

      table.adjacency-matrix th {
        background-color: #f0f0f0;
      }
    </style>
  </head>
  <body>
    <h1>üå± GreenCircuit</h1>
    <p>
      <strong>Optimizaci√≥n de Rutas de Recolecci√≥n de Residuos Urbanos</strong>
    </p>
    <p>
      Aplicaci√≥n del Problema del Agente Viajero (TSP) para minimizar
      distancias, tiempo y emisiones de CO‚ÇÇ.
    </p>

    <hr />

    <!-- SECCI√ìN 1: CONFIGURACI√ìN -->
    <section id="config-section">
      <h2>1Ô∏è‚É£ Configuraci√≥n del Grafo</h2>
      <div class="info-box">
        Ingresa el n√∫mero de puntos de recolecci√≥n (N) que deseas optimizar.
        <br />N debe estar entre 8 y 16 nodos.
      </div>

      <label for="input-n"><strong>N√∫mero de puntos (N):</strong></label>
      <input type="number" id="input-n" min="8" max="16" value="10" />

      <button id="btn-config">‚úÖ Configurar</button>

      <div id="config-status" style="margin-top: 10px"></div>
    </section>

    <!-- SECCI√ìN 2: GENERACI√ìN -->
    <section id="generation-section" class="hidden">
      <h2>2Ô∏è‚É£ Generaci√≥n del Grafo</h2>
      <div class="info-box">Elige c√≥mo generar los puntos de recolecci√≥n.</div>

      <button id="btn-random">üé≤ Generar Aleatoriamente</button>
      <button id="btn-random-circular">‚≠ï Generar en C√≠rculo</button>
      <button id="btn-random-grid">‚äû Generar en Grid</button>

      <div id="generation-status" style="margin-top: 10px"></div>
    </section>

    <!-- SECCI√ìN 3: VISUALIZACI√ìN DEL GRAFO -->
    <section id="visualization-section">
      <h2>3Ô∏è‚É£ Visualizaci√≥n del Grafo</h2>
      <div id="graph-info" class="info-box" style="display: none">
        <strong>Informaci√≥n del grafo:</strong>
        <div id="graph-stats"></div>
      </div>
      <div id="graph-container"></div>
      <div style="margin-top: 10px">
        <button id="btn-fit-view">üîç Ajustar Vista</button>
        <button id="btn-reset-view">üîÑ Resetear Vista</button>
      </div>
    </section>

    <!-- SECCI√ìN 4: CONTROLES DE EJECUCI√ìN -->
    <section id="controls-section" class="hidden">
      <h2>4Ô∏è‚É£ Controles de Ejecuci√≥n</h2>
      <div class="info-box">
        Selecciona la velocidad de ejecuci√≥n del algoritmo.<br />
        <strong>‚ö†Ô∏è Nota:</strong> Para N > 10, se recomienda usar modo Lento o
        Manual para evitar que el navegador se congele.
      </div>

      <div>
        <strong>Velocidad:</strong><br />
        <button id="btn-fast">‚ö° R√°pido (con pausas)</button>
        <button id="btn-slow">üê¢ Lento (1 seg/paso)</button>
        <button id="btn-manual-step">üëÜ Manual (click por click)</button>
      </div>

      <div id="manual-controls" class="hidden" style="margin-top: 10px">
        <button id="btn-next-step">‚û°Ô∏è Siguiente Paso</button>
      </div>

      <div style="margin-top: 15px">
        <button
          id="btn-execute"
          style="
            background-color: #4caf50;
            color: white;
            font-weight: bold;
            padding: 15px 30px;
          "
        >
          ‚ñ∂Ô∏è EJECUTAR ALGORITMO
        </button>
      </div>

      <div id="execution-status" style="margin-top: 10px"></div>
      <div id="progress-container" class="hidden">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
        </div>
        <div id="progress-text">Progreso: 0%</div>
      </div>
    </section>

    <!-- SECCI√ìN 5: LOGS Y RESULTADOS -->
    <section id="results-section">
      <h2>5Ô∏è‚É£ Proceso y Resultados</h2>
      <div style="margin-bottom: 10px">
        <button id="btn-clear-logs">üóëÔ∏è Limpiar Logs</button>
      </div>
      <div id="log-container"></div>
    </section>

    <footer
      style="
        margin-top: 30px;
        padding-top: 20px;
        border-top: 1px solid #ddd;
        text-align: center;
        color: #666;
      "
    >
      <p>
        üå± <strong>GreenCircuit</strong> - Optimizaci√≥n de Rutas de Recolecci√≥n
        de Residuos
      </p>
      <p>Problema del Agente Viajero aplicado a sostenibilidad urbana</p>
    </footer>

    <!-- TODO EL JAVASCRIPT EN UN SOLO BLOQUE -->
    <script>
      // ============================================================================
      // APLICACI√ìN GREENCIRCUIT - VERSI√ìN MONOL√çTICA (Sin ES6 Modules)
      // ============================================================================

      console.log("üå± Iniciando GreenCircuit (versi√≥n standalone)...");

      // ============================================================================
      // CLASE: Graph
      // ============================================================================
      class Graph {
        constructor(n) {
          if (n < 8 || n > 16) {
            throw new Error("N debe estar entre 8 y 16");
          }

          this.n = n;
          this.nodes = [];
          this.edges = [];
          this.adjacencyMatrix = [];
        }

        addNode(node) {
          if (this.nodes.length >= this.n) {
            throw new Error(`No se pueden agregar m√°s de ${this.n} nodos`);
          }

          if (this.nodes.find((n) => n.id === node.id)) {
            throw new Error(`El nodo con id ${node.id} ya existe`);
          }

          this.nodes.push({
            id: node.id,
            name: node.name || `Punto ${node.id}`,
            x: node.x || 0,
            y: node.y || 0,
            wasteAmount: node.wasteAmount || 0,
            type: node.type || "residencial",
          });
        }

        addEdge(from, to, distance = null) {
          const nodeFrom = this.nodes.find((n) => n.id === from);
          const nodeTo = this.nodes.find((n) => n.id === to);

          if (!nodeFrom || !nodeTo) {
            throw new Error(`Uno o ambos nodos no existen: ${from}, ${to}`);
          }

          if (distance === null) {
            distance = this.calculateDistance(nodeFrom, nodeTo);
          }

          const time = (distance / 25) * 60;

          this.edges.push({
            from,
            to,
            distance: parseFloat(distance.toFixed(2)),
            time: parseFloat(time.toFixed(2)),
            co2PerKm: 0.2,
          });
        }

        calculateDistance(node1, node2) {
          const dx = node2.x - node1.x;
          const dy = node2.y - node1.y;
          return Math.sqrt(dx * dx + dy * dy) * 0.01;
        }

        buildAdjacencyMatrix() {
          const n = this.nodes.length;
          this.adjacencyMatrix = Array(n)
            .fill(null)
            .map(() => Array(n).fill(Infinity));

          for (let i = 0; i < n; i++) {
            this.adjacencyMatrix[i][i] = 0;
          }

          this.edges.forEach((edge) => {
            const fromIndex = this.nodes.findIndex((n) => n.id === edge.from);
            const toIndex = this.nodes.findIndex((n) => n.id === edge.to);

            if (fromIndex !== -1 && toIndex !== -1) {
              this.adjacencyMatrix[fromIndex][toIndex] = edge.distance;
              this.adjacencyMatrix[toIndex][fromIndex] = edge.distance;
            }
          });
        }

        getMatrix() {
          if (this.adjacencyMatrix.length === 0) {
            this.buildAdjacencyMatrix();
          }
          return this.adjacencyMatrix;
        }

        hasEdge(from, to) {
          return this.edges.some(
            (e) =>
              (e.from === from && e.to === to) ||
              (e.from === to && e.to === from)
          );
        }

        getDistance(from, to) {
          const edge = this.edges.find(
            (e) =>
              (e.from === from && e.to === to) ||
              (e.from === to && e.to === from)
          );
          return edge ? edge.distance : null;
        }

        isComplete() {
          const n = this.nodes.length;
          const expectedEdges = (n * (n - 1)) / 2;
          const uniqueEdges = new Set();

          this.edges.forEach((edge) => {
            const key =
              edge.from < edge.to
                ? `${edge.from}-${edge.to}`
                : `${edge.to}-${edge.from}`;
            uniqueEdges.add(key);
          });

          return uniqueEdges.size === expectedEdges;
        }

        getInfo() {
          return {
            nodeCount: this.nodes.length,
            edgeCount: this.edges.length,
            isComplete: this.isComplete(),
            totalWaste: this.nodes.reduce(
              (sum, node) => sum + node.wasteAmount,
              0
            ),
          };
        }
      }

      // ============================================================================
      // CLASE: RandomGenerator
      // ============================================================================
      class RandomGenerator {
        static WASTE_TYPES = ["residencial", "comercial", "industrial"];
        static ZONE_NAMES = [
          "Centro",
          "Norte",
          "Sur",
          "Este",
          "Oeste",
          "Plaza Mayor",
          "Parque",
          "Mercado",
          "Estaci√≥n",
          "Universidad",
          "Hospital",
          "Pol√≠gono",
          "Barrio Alto",
          "Puerto",
          "Avenida",
          "Residencial",
          "Industrial",
        ];

        static generate(n, options = {}) {
          const { width = 800, height = 600 } = options;

          if (n < 8 || n > 16) {
            throw new Error("N debe estar entre 8 y 16");
          }

          const nodes = [];
          const usedNames = new Set();

          for (let i = 0; i < n; i++) {
            let x, y, tooClose;
            let attempts = 0;
            const minDistance = Math.min(width, height) / (n / 2);

            do {
              x = Math.random() * (width - 100) + 50;
              y = Math.random() * (height - 100) + 50;

              tooClose = nodes.some((node) => {
                const dx = node.x - x;
                const dy = node.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < minDistance;
              });

              attempts++;
            } while (tooClose && attempts < 50);

            let name;
            do {
              const zoneName =
                this.ZONE_NAMES[
                  Math.floor(Math.random() * this.ZONE_NAMES.length)
                ];
              const letter = String.fromCharCode(65 + i);
              name = `Punto ${letter} - ${zoneName}`;
            } while (usedNames.has(name));
            usedNames.add(name);

            const rand = Math.random();
            let type;
            if (rand < 0.6) {
              type = "residencial";
            } else if (rand < 0.85) {
              type = "comercial";
            } else {
              type = "industrial";
            }

            let wasteAmount;
            if (type === "residencial") {
              wasteAmount = Math.floor(Math.random() * (50 - 20 + 1)) + 20;
            } else if (type === "comercial") {
              wasteAmount = Math.floor(Math.random() * (80 - 40 + 1)) + 40;
            } else {
              wasteAmount = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
            }

            nodes.push({
              id: i,
              name,
              x: Math.round(x),
              y: Math.round(y),
              wasteAmount,
              type,
            });
          }

          return nodes;
        }

        static generateCircularLayout(n, options = {}) {
          const { centerX = 400, centerY = 300, radius = 200 } = options;

          if (n < 8 || n > 16) {
            throw new Error("N debe estar entre 8 y 16");
          }

          const nodes = [];
          const angleStep = (2 * Math.PI) / n;

          for (let i = 0; i < n; i++) {
            const angle = i * angleStep - Math.PI / 2;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);

            const type =
              this.WASTE_TYPES[
                Math.floor(Math.random() * this.WASTE_TYPES.length)
              ];
            const wasteAmount = Math.floor(Math.random() * (100 - 20 + 1)) + 20;
            const zoneName = this.ZONE_NAMES[i % this.ZONE_NAMES.length];

            nodes.push({
              id: i,
              name: `Punto ${String.fromCharCode(65 + i)} - ${zoneName}`,
              x: Math.round(x),
              y: Math.round(y),
              wasteAmount,
              type,
            });
          }

          return nodes;
        }

        static generateGridLayout(n, options = {}) {
          const { width = 800, height = 600 } = options;

          if (n < 8 || n > 16) {
            throw new Error("N debe estar entre 8 y 16");
          }

          const nodes = [];
          const cols = Math.ceil(Math.sqrt(n));
          const rows = Math.ceil(n / cols);

          const cellWidth = (width - 100) / cols;
          const cellHeight = (height - 100) / rows;

          for (let i = 0; i < n; i++) {
            const row = Math.floor(i / cols);
            const col = i % cols;

            const x = 50 + col * cellWidth + cellWidth / 2;
            const y = 50 + row * cellHeight + cellHeight / 2;

            const type =
              this.WASTE_TYPES[
                Math.floor(Math.random() * this.WASTE_TYPES.length)
              ];
            const wasteAmount = Math.floor(Math.random() * (100 - 20 + 1)) + 20;
            const zoneName = this.ZONE_NAMES[i % this.ZONE_NAMES.length];

            nodes.push({
              id: i,
              name: `Punto ${String.fromCharCode(65 + i)} - ${zoneName}`,
              x: Math.round(x),
              y: Math.round(y),
              wasteAmount,
              type,
            });
          }

          return nodes;
        }

        static generateCompleteGraph(nodes) {
          const edges = [];
          const n = nodes.length;

          for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
              const from = nodes[i];
              const to = nodes[j];

              const dx = to.x - from.x;
              const dy = to.y - from.y;
              const distance = Math.sqrt(dx * dx + dy * dy) * 0.01;

              edges.push({
                from: from.id,
                to: to.id,
                distance: parseFloat(distance.toFixed(2)),
              });
            }
          }

          return edges;
        }

        static getStatistics(nodes) {
          const totalWaste = nodes.reduce(
            (sum, node) => sum + node.wasteAmount,
            0
          );
          const wasteByType = {};

          this.WASTE_TYPES.forEach((type) => {
            const nodesOfType = nodes.filter((n) => n.type === type);
            wasteByType[type] = {
              count: nodesOfType.length,
              totalWaste: nodesOfType.reduce(
                (sum, n) => sum + n.wasteAmount,
                0
              ),
              avgWaste:
                nodesOfType.length > 0
                  ? nodesOfType.reduce((sum, n) => sum + n.wasteAmount, 0) /
                    nodesOfType.length
                  : 0,
            };
          });

          return {
            totalNodes: nodes.length,
            totalWaste,
            avgWaste: totalWaste / nodes.length,
            wasteByType,
            minWaste: Math.min(...nodes.map((n) => n.wasteAmount)),
            maxWaste: Math.max(...nodes.map((n) => n.wasteAmount)),
          };
        }
      }

      // ============================================================================
      // CLASE: HamiltonianFinder
      // ============================================================================
      class HamiltonianFinder {
        constructor(graph) {
          this.graph = graph;
          this.cycles = [];
          this.steps = [];
          this.visitCount = 0;
        }

        findAllCycles(startNode = 0) {
          this.cycles = [];
          this.steps = [];
          this.visitCount = 0;

          const n = this.graph.nodes.length;

          if (n < 3) {
            return [];
          }

          const visited = Array(n).fill(false);
          const path = [startNode];
          visited[startNode] = true;

          this._backtrack(path, visited, startNode, startNode);

          return this.cycles;
        }

        _backtrack(path, visited, currentNode, startNode) {
          this.visitCount++;

          const n = this.graph.nodes.length;

          if (path.length === n) {
            if (this.graph.hasEdge(currentNode, startNode)) {
              const cycle = [...path, startNode];
              this.cycles.push(cycle);
            }
            return;
          }

          for (let i = 0; i < n; i++) {
            const nextNode = this.graph.nodes[i].id;

            if (!visited[i] && this.graph.hasEdge(currentNode, nextNode)) {
              visited[i] = true;
              path.push(nextNode);

              this._backtrack(path, visited, nextNode, startNode);

              visited[i] = false;
              path.pop();
            }
          }
        }

        getStatistics() {
          return {
            cyclesFound: this.cycles.length,
            totalSteps: this.steps.length,
            nodesVisited: this.visitCount,
          };
        }
      }

      // ============================================================================
      // CLASE: TSPSolver
      // ============================================================================
      class TSPSolver {
        constructor(graph, hamiltonianCycles) {
          this.graph = graph;
          this.cycles = hamiltonianCycles;
          this.results = [];
          this.optimalSolution = null;
          this.worstSolution = null;
        }

        solve() {
          if (this.cycles.length === 0) {
            throw new Error("No hay ciclos hamiltonianos para evaluar");
          }

          this.results = [];
          let minDistance = Infinity;
          let maxDistance = -Infinity;
          let optimalIndex = -1;
          let worstIndex = -1;

          this.cycles.forEach((cycle, index) => {
            const distance = this._calculateCycleDistance(cycle);
            const time = (distance / 25) * 60;
            const co2 = distance * 0.2;

            const result = {
              cycle,
              distance,
              time: parseFloat(time.toFixed(2)),
              co2: parseFloat(co2.toFixed(2)),
              index,
            };

            this.results.push(result);

            if (distance < minDistance) {
              minDistance = distance;
              optimalIndex = index;
            }

            if (distance > maxDistance) {
              maxDistance = distance;
              worstIndex = index;
            }
          });

          this.optimalSolution = this.results[optimalIndex];
          this.worstSolution = this.results[worstIndex];

          const distanceSaved =
            this.worstSolution.distance - this.optimalSolution.distance;
          const timeSaved = this.worstSolution.time - this.optimalSolution.time;
          const co2Saved = this.worstSolution.co2 - this.optimalSolution.co2;

          const savings = {
            distanceSaved: parseFloat(distanceSaved.toFixed(2)),
            timeSaved: parseFloat(timeSaved.toFixed(2)),
            co2Saved: parseFloat(co2Saved.toFixed(2)),
            distancePercent: parseFloat(
              ((distanceSaved / this.worstSolution.distance) * 100).toFixed(2)
            ),
            timePercent: parseFloat(
              ((timeSaved / this.worstSolution.time) * 100).toFixed(2)
            ),
            co2Percent: parseFloat(
              ((co2Saved / this.worstSolution.co2) * 100).toFixed(2)
            ),
          };

          return {
            optimal: this.optimalSolution,
            worst: this.worstSolution,
            savings,
            allResults: this.results,
            summary: {
              totalCyclesEvaluated: this.cycles.length,
              bestDistance: this.optimalSolution.distance,
              worstDistance: this.worstSolution.distance,
              averageDistance: this._calculateAverageDistance(),
            },
          };
        }

        _calculateCycleDistance(cycle) {
          let totalDistance = 0;

          for (let i = 0; i < cycle.length - 1; i++) {
            const from = cycle[i];
            const to = cycle[i + 1];
            const distance = this.graph.getDistance(from, to);

            if (distance === null) {
              throw new Error(`No existe arista entre nodos ${from} y ${to}`);
            }

            totalDistance += distance;
          }

          return parseFloat(totalDistance.toFixed(2));
        }

        _calculateAverageDistance() {
          if (this.results.length === 0) return 0;
          const sum = this.results.reduce(
            (acc, result) => acc + result.distance,
            0
          );
          return parseFloat((sum / this.results.length).toFixed(2));
        }

        exportResults() {
          return {
            optimal: this.optimalSolution,
            worst: this.worstSolution,
            allResults: this.results,
          };
        }
      }

      // ============================================================================
      // CLASE: CytoscapeRenderer
      // ============================================================================
      class CytoscapeRenderer {
        constructor(containerElement) {
          this.container = containerElement;
          this.cy = null;
        }

        initialize() {
          if (!window.cytoscape) {
            console.error("Cytoscape.js no est√° cargado");
            return;
          }

          this.cy = cytoscape({
            container: this.container,
            elements: [],

            layout: {
              name: "preset",
            },

            style: [
              {
                selector: "node",
                style: {
                  "background-color": "#4CAF50",
                  label: "data(label)",
                  width: 40,
                  height: 40,
                  "font-size": 12,
                  "text-valign": "center",
                  "text-halign": "center",
                  color: "#000",
                  "text-outline-width": 2,
                  "text-outline-color": "#fff",
                },
              },
              {
                selector: "edge",
                style: {
                  width: 2,
                  "line-color": "#ccc",
                  "curve-style": "bezier",
                  label: "data(label)",
                  "font-size": 10,
                  "text-rotation": "autorotate",
                  "text-margin-y": -10,
                },
              },
              {
                selector: "node.highlighted",
                style: {
                  "background-color": "#FF9800",
                  width: 50,
                  height: 50,
                },
              },
              {
                selector: "edge.optimal-path",
                style: {
                  width: 4,
                  "line-color": "#2196F3",
                  "target-arrow-color": "#2196F3",
                  "target-arrow-shape": "triangle",
                },
              },
              {
                selector: "node.start-node",
                style: {
                  "background-color": "#F44336",
                  width: 50,
                  height: 50,
                },
              },
              {
                selector: 'node[type = "residencial"]',
                style: {
                  "background-color": "#4CAF50",
                },
              },
              {
                selector: 'node[type = "comercial"]',
                style: {
                  "background-color": "#2196F3",
                },
              },
              {
                selector: 'node[type = "industrial"]',
                style: {
                  "background-color": "#FF9800",
                },
              },
            ],

            userZoomingEnabled: true,
            userPanningEnabled: true,
            boxSelectionEnabled: false,
          });
        }

        renderGraph(graph) {
          if (!this.cy) return;

          const elements = [];

          graph.nodes.forEach((node) => {
            elements.push({
              group: "nodes",
              data: {
                id: `node-${node.id}`,
                label: `${String.fromCharCode(65 + node.id)}\n${
                  node.wasteAmount
                }kg`,
                type: node.type,
                wasteAmount: node.wasteAmount,
                name: node.name,
              },
              position: {
                x: node.x,
                y: node.y,
              },
            });
          });

          graph.edges.forEach((edge, index) => {
            elements.push({
              group: "edges",
              data: {
                id: `edge-${index}`,
                source: `node-${edge.from}`,
                target: `node-${edge.to}`,
                label: `${edge.distance.toFixed(1)}km`,
                distance: edge.distance,
              },
            });
          });

          this.cy.elements().remove();
          this.cy.add(elements);
          this.cy.fit(50);
        }

        highlightPath(path) {
          if (!this.cy) return;

          this.clearHighlights();

          for (let i = 0; i < path.length - 1; i++) {
            const fromId = `node-${path[i]}`;
            const toId = `node-${path[i + 1]}`;

            const node = this.cy.getElementById(fromId);
            if (node.length > 0) {
              node.addClass("highlighted");
              if (i === 0) {
                node.addClass("start-node");
              }
            }

            const edge = this.cy.edges(
              `[source = "${fromId}"][target = "${toId}"], [source = "${toId}"][target = "${fromId}"]`
            );
            if (edge.length > 0) {
              edge.addClass("optimal-path");
            }
          }
        }

        clearHighlights() {
          if (!this.cy) return;
          this.cy.elements().removeClass("highlighted optimal-path start-node");
        }

        fitView() {
          if (!this.cy) return;
          this.cy.fit(50);
        }

        resetView() {
          if (!this.cy) return;
          this.cy.reset();
        }
      }

      // ============================================================================
      // CLASE: LogDisplay
      // ============================================================================
      class LogDisplay {
        constructor(containerElement) {
          this.container = containerElement;
          this.logs = [];
        }

        clear() {
          this.container.innerHTML = "";
          this.logs = [];
        }

        log(message, type = "info") {
          const entry = {
            message,
            type,
            timestamp: new Date().toLocaleTimeString(),
          };

          this.logs.push(entry);

          const div = document.createElement("div");
          div.className = `log-entry log-${type}`;

          const timestamp = document.createElement("span");
          timestamp.className = "log-timestamp";
          timestamp.textContent = `[${entry.timestamp}] `;

          const content = document.createElement("span");
          content.className = "log-content";
          content.textContent = message;

          div.appendChild(timestamp);
          div.appendChild(content);

          this.container.appendChild(div);
          this.container.scrollTop = this.container.scrollHeight;
        }

        displayMatrix(matrix) {
          const n = matrix.length;

          this.log("\nüìä MATRIZ DE ADYACENCIA:", "header");

          const table = document.createElement("table");
          table.className = "adjacency-matrix";

          const headerRow = document.createElement("tr");
          headerRow.appendChild(document.createElement("th"));

          for (let i = 0; i < n; i++) {
            const th = document.createElement("th");
            th.textContent = String.fromCharCode(65 + i);
            headerRow.appendChild(th);
          }
          table.appendChild(headerRow);

          for (let i = 0; i < n; i++) {
            const row = document.createElement("tr");

            const rowHeader = document.createElement("th");
            rowHeader.textContent = String.fromCharCode(65 + i);
            row.appendChild(rowHeader);

            for (let j = 0; j < n; j++) {
              const cell = document.createElement("td");
              const value = matrix[i][j];

              if (value === Infinity) {
                cell.textContent = "‚àû";
              } else if (value === 0) {
                cell.textContent = "-";
              } else {
                cell.textContent = value.toFixed(1);
              }

              if (i === j) {
                cell.style.backgroundColor = "#f0f0f0";
              }

              row.appendChild(cell);
            }

            table.appendChild(row);
          }

          this.container.appendChild(table);
          this.container.scrollTop = this.container.scrollHeight;
        }

        displayResults(solution) {
          const { optimal, worst, savings, summary } = solution;

          this.log("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "separator");
          this.log("üèÜ RESULTADOS FINALES", "header");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "separator");

          this.log("\n‚úÖ RUTA √ìPTIMA:", "success");
          this.log(`   Ciclo: ${optimal.cycle.join(" ‚Üí ")}`, "result");
          this.log(
            `   üìè Distancia: ${optimal.distance.toFixed(2)} km`,
            "result"
          );
          this.log(
            `   ‚è±Ô∏è  Tiempo: ${optimal.time.toFixed(2)} minutos`,
            "result"
          );
          this.log(`   üåç CO‚ÇÇ: ${optimal.co2.toFixed(2)} kg`, "result");

          this.log("\n‚ùå PEOR RUTA:", "warning");
          this.log(`   Ciclo: ${worst.cycle.join(" ‚Üí ")}`, "result");
          this.log(
            `   üìè Distancia: ${worst.distance.toFixed(2)} km`,
            "result"
          );

          this.log("\nüí∞ AHORROS LOGRADOS:", "success");
          this.log(
            `   üìè Distancia: -${savings.distanceSaved.toFixed(
              2
            )} km (${savings.distancePercent.toFixed(1)}%)`,
            "savings"
          );
          this.log(
            `   ‚è±Ô∏è  Tiempo: -${savings.timeSaved.toFixed(
              2
            )} min (${savings.timePercent.toFixed(1)}%)`,
            "savings"
          );
          this.log(
            `   üåç CO‚ÇÇ: -${savings.co2Saved.toFixed(
              2
            )} kg (${savings.co2Percent.toFixed(1)}%)`,
            "savings"
          );

          this.log("\nüìä ESTAD√çSTICAS:", "info");
          this.log(
            `   Ciclos evaluados: ${summary.totalCyclesEvaluated}`,
            "info"
          );
          this.log(
            `   Distancia promedio: ${summary.averageDistance.toFixed(2)} km`,
            "info"
          );

          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "separator");
        }
      }

      // ============================================================================
      // APLICACI√ìN PRINCIPAL
      // ============================================================================
      const state = {
        graph: null,
        renderer: null,
        logger: null,
        n: 10,
        isConfigured: false,
        isGenerated: false,
        currentMode: "slow",
        isExecuting: false,
      };

      function init() {
        console.log("Inicializando componentes...");

        state.renderer = new CytoscapeRenderer(
          document.getElementById("graph-container")
        );
        state.renderer.initialize();

        state.logger = new LogDisplay(document.getElementById("log-container"));
        state.logger.log("üå± GreenCircuit iniciado", "success");
        state.logger.log(
          "Sistema listo. Configura el n√∫mero de nodos para comenzar.",
          "info"
        );

        setupEventListeners();

        console.log("‚úÖ GreenCircuit listo (versi√≥n standalone)");
      }

      function setupEventListeners() {
        document
          .getElementById("btn-config")
          .addEventListener("click", onConfigSubmit);
        document
          .getElementById("btn-random")
          .addEventListener("click", () => generateRandom("random"));
        document
          .getElementById("btn-random-circular")
          .addEventListener("click", () => generateRandom("circular"));
        document
          .getElementById("btn-random-grid")
          .addEventListener("click", () => generateRandom("grid"));
        document
          .getElementById("btn-fit-view")
          .addEventListener("click", () => state.renderer.fitView());
        document
          .getElementById("btn-reset-view")
          .addEventListener("click", () => state.renderer.resetView());
        document
          .getElementById("btn-fast")
          .addEventListener("click", () => setExecutionMode("fast"));
        document
          .getElementById("btn-slow")
          .addEventListener("click", () => setExecutionMode("slow"));
        document
          .getElementById("btn-manual-step")
          .addEventListener("click", () => setExecutionMode("manual"));
        document
          .getElementById("btn-execute")
          .addEventListener("click", executeAlgorithm);
        document
          .getElementById("btn-clear-logs")
          .addEventListener("click", () => state.logger.clear());
      }

      function onConfigSubmit() {
        const n = parseInt(document.getElementById("input-n").value);

        if (isNaN(n) || n < 8 || n > 16) {
          showStatus(
            "config-status",
            "‚ùå Error: N debe estar entre 8 y 16",
            "error"
          );
          state.logger.log("Error: N debe estar entre 8 y 16", "error");
          return;
        }

        try {
          state.n = n;
          state.graph = new Graph(n);
          state.isConfigured = true;

          showStatus("config-status", `‚úÖ Configurado: ${n} nodos`, "success");
          state.logger.log(`‚úÖ Grafo configurado con ${n} nodos`, "success");

          document
            .getElementById("generation-section")
            .classList.remove("hidden");
        } catch (error) {
          console.error("Error:", error);
          showStatus("config-status", `‚ùå Error: ${error.message}`, "error");
        }
      }

      function generateRandom(layout = "random") {
        if (!state.isConfigured) {
          state.logger.log(
            "Error: Primero debes configurar el n√∫mero de nodos",
            "error"
          );
          return;
        }

        state.logger.clear();
        state.logger.log(
          `üé≤ Generando ${state.n} nodos en layout ${layout}...`,
          "info"
        );

        try {
          let nodes;

          switch (layout) {
            case "circular":
              nodes = RandomGenerator.generateCircularLayout(state.n, {
                centerX: 400,
                centerY: 250,
              });
              break;
            case "grid":
              nodes = RandomGenerator.generateGridLayout(state.n, {
                width: 800,
                height: 500,
              });
              break;
            default:
              nodes = RandomGenerator.generate(state.n, {
                width: 800,
                height: 500,
              });
          }

          nodes.forEach((node) => state.graph.addNode(node));

          const edges = RandomGenerator.generateCompleteGraph(
            state.graph.nodes
          );
          edges.forEach((edge) =>
            state.graph.addEdge(edge.from, edge.to, edge.distance)
          );

          state.renderer.renderGraph(state.graph);

          const info = state.graph.getInfo();
          const stats = RandomGenerator.getStatistics(state.graph.nodes);

          state.logger.log(`‚úÖ Grafo generado exitosamente`, "success");
          state.logger.log(`   Nodos: ${info.nodeCount}`, "info");
          state.logger.log(`   Aristas: ${info.edgeCount}`, "info");
          state.logger.log(
            `   Total de residuos: ${info.totalWaste} kg`,
            "info"
          );

          showStatus(
            "generation-status",
            "‚úÖ Grafo generado correctamente",
            "success"
          );
          showGraphInfo(info, stats);

          state.isGenerated = true;
          document
            .getElementById("controls-section")
            .classList.remove("hidden");
        } catch (error) {
          state.logger.log(`‚ùå Error: ${error.message}`, "error");
          showStatus(
            "generation-status",
            `‚ùå Error: ${error.message}`,
            "error"
          );
        }
      }

      function setExecutionMode(mode) {
        state.currentMode = mode;
        state.logger.log(`‚öôÔ∏è Modo de ejecuci√≥n: ${mode}`, "info");
        showStatus("execution-status", `Modo: ${mode}`, "info");

        if (mode === "manual") {
          document.getElementById("manual-controls").classList.remove("hidden");
        } else {
          document.getElementById("manual-controls").classList.add("hidden");
        }
      }

      async function executeAlgorithm() {
        if (!state.isGenerated) {
          state.logger.log("‚ùå Error: Primero debes generar el grafo", "error");
          return;
        }

        if (state.isExecuting) {
          state.logger.log("‚ö†Ô∏è Ya hay una ejecuci√≥n en curso", "warning");
          return;
        }

        try {
          state.isExecuting = true;
          document.getElementById("btn-execute").disabled = true;
          document
            .getElementById("progress-container")
            .classList.remove("hidden");

          state.logger.clear();
          state.logger.log(
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
            "separator"
          );
          state.logger.log("‚ñ∂Ô∏è INICIANDO ALGORITMO", "header");
          state.logger.log(
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
            "separator"
          );

          updateProgress(10, "Construyendo matriz de adyacencia...");
          await delay(100);

          // FASE 1: Matriz
          state.logger.log("\n--- FASE 1: MATRIZ DE ADYACENCIA ---", "phase");
          state.graph.buildAdjacencyMatrix();
          state.logger.log("‚úÖ Matriz construida", "success");
          state.logger.displayMatrix(state.graph.getMatrix());
          await delay(state.currentMode === "fast" ? 500 : 1000);

          updateProgress(25, "Buscando ciclos hamiltonianos...");

          // FASE 2: Ciclos Hamiltonianos
          state.logger.log("\n--- FASE 2: CICLOS HAMILTONIANOS ---", "phase");

          const finder = new HamiltonianFinder(state.graph);

          // Ejecutar b√∫squeda de ciclos con actualizaciones de progreso
          const cycles = await findCyclesWithProgress(finder);

          if (cycles.length === 0) {
            state.logger.log(
              "‚ùå No se encontraron ciclos hamiltonianos",
              "error"
            );
            return;
          }

          state.logger.log(
            `‚úÖ Se encontraron ${cycles.length} ciclos`,
            "success"
          );

          // Mostrar algunos ciclos (no todos si son muchos)
          const cyclesToShow = Math.min(cycles.length, 10);
          state.logger.log(
            `\nMostrando primeros ${cyclesToShow} ciclos:`,
            "info"
          );
          for (let i = 0; i < cyclesToShow; i++) {
            state.logger.log(
              `  Ciclo #${i + 1}: ${cycles[i].join(" ‚Üí ")}`,
              "cycle"
            );
          }
          if (cycles.length > cyclesToShow) {
            state.logger.log(
              `  ... y ${cycles.length - cyclesToShow} ciclos m√°s`,
              "info"
            );
          }

          await delay(state.currentMode === "fast" ? 500 : 1000);

          updateProgress(60, "Resolviendo TSP...");

          // FASE 3: TSP
          state.logger.log(
            "\n--- FASE 3: PROBLEMA DEL AGENTE VIAJERO ---",
            "phase"
          );
          state.logger.log(`Evaluando ${cycles.length} ciclos...`, "info");

          const solver = new TSPSolver(state.graph, cycles);

          // Resolver TSP con actualizaciones de progreso
          const solution = await solveTSPWithProgress(solver);

          updateProgress(90, "Generando resultados...");

          state.logger.log("‚úÖ TSP resuelto", "success");
          await delay(500);

          // FASE 4: Resultados
          state.logger.log("\n--- FASE 4: RESULTADOS ---", "phase");

          const fullSolution = solver.exportResults();
          state.logger.displayResults({
            optimal: fullSolution.optimal,
            worst: fullSolution.worst,
            savings: solution.savings,
            summary: solution.summary,
          });

          state.renderer.highlightPath(fullSolution.optimal.cycle);
          state.logger.log("\n‚úÖ Ruta √≥ptima destacada en el grafo", "success");

          updateProgress(100, "Completado");
          showStatus("execution-status", "‚úÖ Algoritmo completado", "success");
        } catch (error) {
          state.logger.log(`‚ùå Error: ${error.message}`, "error");
          console.error("Error:", error);
        } finally {
          state.isExecuting = false;
          document.getElementById("btn-execute").disabled = false;
          setTimeout(() => {
            document
              .getElementById("progress-container")
              .classList.add("hidden");
          }, 2000);
        }
      }

      // Funci√≥n auxiliar para buscar ciclos con pausas (evita congelamiento)
      async function findCyclesWithProgress(finder) {
        const startTime = Date.now();
        const cycles = finder.findAllCycles(0);
        const duration = Date.now() - startTime;

        if (duration > 100) {
          await delay(100); // Pausa para que el navegador respire
        }

        updateProgress(50, `Encontrados ${cycles.length} ciclos`);
        return cycles;
      }

      // Funci√≥n auxiliar para resolver TSP con pausas
      async function solveTSPWithProgress(solver) {
        const solution = solver.solve();
        await delay(100); // Pausa para actualizaci√≥n de UI
        return solution;
      }

      function updateProgress(percent, message) {
        const progressFill = document.getElementById("progress-fill");
        const progressText = document.getElementById("progress-text");

        if (progressFill && progressText) {
          progressFill.style.width = `${percent}%`;
          progressText.textContent = `Progreso: ${percent}% - ${message}`;
        }
      }

      function showGraphInfo(info, stats) {
        const infoDiv = document.getElementById("graph-info");
        const statsDiv = document.getElementById("graph-stats");

        statsDiv.innerHTML = `
        <p>üìä Nodos: ${info.nodeCount} | Aristas: ${
          info.edgeCount
        } | Completo: ${info.isComplete ? "S√≠" : "No"}</p>
        <p>üì¶ Total residuos: ${
          info.totalWaste
        } kg | Promedio: ${stats.avgWaste.toFixed(1)} kg/punto</p>
        <p>üèòÔ∏è Residencial: ${
          stats.wasteByType.residencial?.count || 0
        } puntos | 
           üè¢ Comercial: ${stats.wasteByType.comercial?.count || 0} puntos | 
           üè≠ Industrial: ${stats.wasteByType.industrial?.count || 0} puntos</p>
      `;

        infoDiv.style.display = "block";
      }

      function showStatus(elementId, message, type = "info") {
        const element = document.getElementById(elementId);
        if (element) {
          element.textContent = message;
          element.style.color =
            type === "error"
              ? "#F44336"
              : type === "success"
              ? "#4CAF50"
              : "#2196F3";
        }
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      // Iniciar cuando el DOM est√© listo
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }

      console.log("‚úÖ Script cargado completamente");
    </script>
  </body>
</html>
